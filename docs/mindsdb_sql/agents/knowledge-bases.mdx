---
title: Knowledge Base
sidebarTitle: Knowledge Base
---

A knowledge base is an advanced system designed to go beyond traditional data storage.

<p align="center">
  <img src="https://docs.google.com/drawings/d/e/2PACX-1vTVmUqhoFXLF3ncL0NWwgdPjI7Hj19f-5xU8ED31ntYvlsTM3poM9zZKwcrEwzvxJrOhl2raIFKWlsp/pub?w=1342&h=681" />
</p>

It intelligently organizes information in semantically meaningful ways, allowing for context-aware retrieval based on meaning rather than just keywords. With the ability to perform semantic reasoning across multiple pieces of information, it delivers deeper insights and more accurate responses.

## Create a Knowledge Base

Here is the syntax for creating a knowledge base:

```sql
CREATE KNOWLEDGE_BASE <kb_name>
USING
    embedding_model = <embedding_model_name>, -- optional
    rerank_model = <reranking_model_name>, -- optional
    storage = <storage_handler_name>, -- optional
    metadata_columns = ['date', 'creator', ...], -- optional
    content_columns = ['review', 'content', ...], -- optional
    id_column = 'id'; -- optional
```

Upon execution, it registers the `<kb_name>` and associates the specified or default models and storage handler.

The following is an explanation of the syntax and parameters:

* `<kb_name>` is a unique user-defined identifier.
* `embedding_model` is an optional parameter. It assigns a pre-existing [embedding model for generating vector embeddings](integrations/ai-engines/langchain_embedding).
      * If not provided, the system shall use the model specified by the `DEFAULT_EMBEDDING_MODEL` system configuration/variable.
* `rerank_model` is an optional parameter. It assigns a pre-existing reranking model for re-ranking search results.
      * If not provided, the system shall use the model specified by the `DEFAULT_RERANKING_MODEL` system configuration/variable (if any).
* `storage` is an optional parameter. It assigns a configured vector database handler.
      * If not provided, the system shall use the handler designated as the system default (that is, ChromaDB).
* `metadata_columns` provides the list of column names that will be stored in the `metadata` column of the knowledge base. If not set, the `metadata` column is not used.
* `content_columns` provides the list of column names that will be stored in the `content` column of the knowledge base. If not set, all columns are stored in the `content` column.
* `id_column` is the column name that will be stored in the `id` column of the knowledge base to uniquely identitify the data.

Get details about the knowledge base using the `DESCRIBE` command.

```sql
DESCRIBE KNOWLEDGE_BASE <kb_name>;
```

<Accordion title="Examples">

Here are the usage examples:

* Creating a knowledge base using defaults:

```sql
CREATE KNOWLEDGE BASE my_kb;
```

* Creating a knowledge base specifying the embedding model:

```sql
CREATE KNOWLEDGE BASE my_kb_custom_embed
USING
    model = my_embedding_model_v1;
```
</Accordion>

## Insert into a Knowledge Base

Here is the syntax for inserting into a knowledge base:

```sql
INSERT INTO <kb_name> ( 
            SELECT <id_col> AS id, <text_col> AS content 
            FROM <source_table> 
      );
```

Upon execution, it inserts data into a knowledge base, using the embedding model to embed it into vectors before inserting into an underlying vector database. For each data row, it apply text chunking (if configured), generates vector embeddings for `content` (or chunks) using the KB's `embedding_model`, and persist ID, content, chunks, embeddings, and any other selected metadata (if supported) via the KB's `storage` handler.

The following is an explanation of the syntax and parameters:

* `<kb_name>` is a unique identifier of a knowledge base.
* `<id_col>` is a column that contains unique identifiers of data.
* `<text_col>` is a column (or a set of columns) that contain the text content. It must be explicitly aliased `AS content` for the system to identify it as the primary text for indexing.

<Accordion title="Partitioning Queries for Better Performance">

The following features are covered here:

- Run the `INSERT INTO` query in partitions. A batch can be split into separate workers for improved performance.
- Track progress of the query and manage queries in progress, that is, resume or cancel queries.
- When a query is finished, it is stored in the `queries` table with a `finished_at` timestamp. If a user runs another query, all finished queries older than one day are removed.
- Option to skip errors: When `error='skip'` is used, errors in partitions are skipped.

**Examples of statements**

```sql
-- Transfer data between tables 
INSERT INTO my_kb 
SELECT * FROM db1.table1
WHERE ws_id = 3
USING batch_size=200, track_column=id;

-- Add predictor in pipeline
INSERT INTO my_kb
SELECT * FROM db1.table1
JOIN my_model
USING batch_size=200, track_column=id, threads=true;

-- Load knowledge base, skip errors
INSERT INTO my_kb
SELECT * FROM db1.table1
USING batch_size=200, track_column=id, threads=10, error='skip';

-- Perform prediction in threads and return data 
INSERT INTO my_kb
SELECT * FROM db1.table1
JOIN my_model
USING batch_size=200, track_column=id, threads=10;
```

**Parameters**

- **batch_size** - Number of rows fetched per iteration (default: `1000`).
- **threads** - Run partitioning in threads (optional, bool or int):
  - `int` - Number of threads.
  - `true` - Auto-detect thread count.
  - `false` - Disable threads even if ML task queue is enabled.
- **track_column** - Column used for partitioning; query is sorted by this column and limited by batch_size.
- **error** (default: `raise`):
  - `error='skip'` - Skips errors in partitions.



**View queries in progress**

```sql
SELECT * FROM information_schema.queries;
```

**Repeat a query**

If a query fails, its state is saved:
- Current step number (in database)
- Current step data (cached in files or Redis)

Users can resolve the issue and resume the query:

```sql
-- Use the query ID
SELECT query_resume(1);
```

**Stop or remove a query**

```sql
-- Use the query ID
SELECT query_cancel(1);
```

**Improving performance**

If a model is used in a query or loaded into the knowledge base (to generate embeddings), execution can be optimized by splitting the batch into chunks and processing them in threads.

- If the [ML task queue](/setup/custom-config#overview-of-config-parameters) is enabled, threads are automatically used for prediction.
- It speeds up CPU-bound predictions.
- If prediction uses API services (like OpenAI), threads speed up execution even if the ML task queue is not enabled.
</Accordion>

<Accordion title="Examples">

Here are the usage examples:

* Inserting into a knowledge base:

```sql
INSERT INTO my_kb ( SELECT id, book_abstract AS content FROM my_books );
```
</Accordion>

## Search a Knowledge Base

### Semantic Search at the Document Level

KBs provide semantic search returning document-level relevance.

```sql
SELECT id, relevance 
FROM <kb_name> 
WHERE content = '<query_text>' 
LIMIT <N>;
```

Upon execution, it performs the semantic search workflow (including embedding the query, searching vectors, and optionally reranking) and returns document identifiers and relevance scores.

The following is an explanation of the syntax and parameters:

* `SELECT id, relevance` specifies that the unique document identifier and its calculated relevance score should be returned.
* `<kb_name>` is a unique identifier of a knowledge base.
* `WHERE content = '<query_text>'` triggers semantic search based on the meaning of `<query_text>`.
* `LIMIT <N>` restricts results to the top N most relevant documents.

<Accordion title="Examples">

Here are the usage examples:

* Returning top k most relevant documents:

```sql
SELECT id, relevance 
FROM my_kb 
WHERE content = 'a novel about epic inter planetary intelligence' 
LIMIT 10;
```
</Accordion>

### Semantic Search at the Chunk Level

KBs provide semantic search returning chunk-level details.

```sql
SELECT id, chunk_id, chunk_content, chunk_relevance 
FROM <kb_name> 
WHERE content = '<query_text>' 
LIMIT <N>;
```

Upon execution, it performs the semantic search workflow (including embedding the query, searching vectors, and optionally reranking) and returns details pertaining to the specific text chunks that matched the query most closely.

The following is an explanation of the syntax and parameters:

* `SELECT id, chunk_id, chunk_content, chunk_relevance` specifies that the unique document identifier, chunk identifier, chunk content, and the chunk relevance score should be returned.
* `<kb_name>` is a unique identifier of a knowledge base.
* `WHERE content = '<query_text>'` triggers semantic search based on the meaning of `<query_text>`.
* `LIMIT <N>` restricts results to the top N most relevant documents.

<Accordion title="Examples">

Here are the usage examples:

* Returning top k most relevant chunks:

```sql
SELECT id, chunk_id, chunk_content, chunk_relevance 
FROM my_kb 
WHERE content = 'a novel about epic inter planetary intelligence' 
LIMIT 10;
```
</Accordion>

### Metadata Filtering with Semantic Search

KBs combine semantic search with standard SQL filtering on metadata.

```sql
SELECT id, chunk_content, chunk_relevance 
FROM my_kb 
WHERE id LIKE '<id_pattern>' -- metadata filtering conditions
AND content = '<query_text>'; -- semantic search condition
```

Upon execution, it performs the conjunctive filtering, that is, results must satisfy both the semantic search condition and the metadata condition(s).

The following is an explanation of the syntax and parameters:

* `SELECT id, chunk_content, chunk_relevance` specifies that the unique document identifier, chunk content, and the chunk relevance score should be returned.
* `<kb_name>` is a unique identifier of a knowledge base.
* `WHERE id LIKE '<id_pattern>'` is the metadata filtering condition.
* `WHERE content = '<query_text>'` is the semantic search condition.

<Accordion title="Examples">

Here are the usage examples:

* Filtering results:

```sql
SELECT id, chunk_content, chunk_relevance 
FROM my_kb 
WHERE content = 'a novel about ...' -- semantic search condition
WHERE id LIKE 'fiction%' -- metadata filtering conditions
AND content = 'a novel about ...';
```
</Accordion>

## `JOIN` Support

KBs can be used in the standard SQL JOIN statements.

```sql
SELECT t.id, t.title, kb.chunk_content, kb.relevance
FROM <other_table> AS t
JOIN <kb_name> AS kb 
ON t.<key_col> = kb.id
WHERE <table_filter_condition> -- filter on non-KB table
AND kb.content = '<query_text>'; -- semantic search filter on a KB
```

The following is an explanation of the syntax and parameters:

* `SELECT t.id, t.title, kb.chunk_content, kb.relevance` specified the columns selected from a table (`t`) and a knowledge base (`kb`).
* `WHERE <table_filter_condition>` sets conditions on a table.
* `AND kb.content = '<query_text>'` sets a semantic search condition on a knowledge base.

<Note>
Here are the conditions supported by the available vector stores:

| Handler  |  IN, NOT IN | LIKE, NOT LIKE | < and > | !=  |
| -------- | ----------- | -------------- | ------- | --- |
| PgVector | +           | +              | +       | +   |
| ChromaDB | +           | -              | -       | +   |
</Note>

<Accordion title="Examples">

Here are the usage examples:

* Joining a knowledge base with a data table:

```sql
SELECT books.id, books.title, my_kb.chunk_content, my_kb.relevance
FROM books
LEFT JOIN my_kb AS kb 
ON books.id = my_kb.id
WHERE books.topic = 'fantasy'
AND my_kb.content = 'a novel about benevolent ai';
```
</Accordion>


## Delete from a Knowledge Base

Here is the syntax for deleting from a knowledge base:

```sql
DELETE FROM <kb_name> WHERE <condition>;
```

Upon execution, it identifies matching records based on the user-defined condition and removes all associated data (metadata, content, chunks, embeddings) for matching records from the KB's storage.

The following is an explanation of the syntax and parameters:

* `<kb_name>` is a unique identifier of a knowledge base.
* `<condition>` is a standard SQL WHERE clause condition operating on stored metadata, primarily the unique record identifier (id). Operators like `=`, `IN`, `LIKE`, `>`, `<`, `!=`, `NOT LIKE`, `NOT IN` are supported.

<Accordion title="Examples">

Here are the usage examples:

* Deleting from a knowledge base:

```sql
DELETE FROM my_kb WHERE id IN ('scifi_001', 'scifi_0010', 'bus_89');
```
</Accordion>

